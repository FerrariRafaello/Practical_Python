"""
MRO (Method Resolution Order) is related to multiple inheritance.
It determines the order in which base classes are looked up when searching for a method.
You can access MRO using:
    __mro__   # Returns a tuple
    mro()     # Returns a list
"""

# Simple class to demonstrate MRO
class P:
    pass

p = P()
print(P.__mro__)  # Tuple of the MRO
print(P.mro())    # List of the MRO

# Example with inheritance
class Vehicle:
    pass

class Car(Vehicle):
    pass

class Train(Vehicle):
    pass

print(Vehicle.mro())  # [Vehicle, object]
print(Car.mro())      # [Car, Vehicle, object]

# Multiple inheritance
class CarTrain(Car, Train):
    pass

print(CarTrain.mro())  # MRO for CarTrain including both Car and Train

# Using 'super', MRO is followed automatically
class Vehicle:
    def __init__(self) -> None:
        print("Vehicle __init__ called")

class Car(Vehicle):
    # Modern super() usage; no need to repeat the class name
    def __init__(self) -> None:
        super().__init__()
        print("Car __init__ called")

# Instantiate Car to show the MRO in action
car = Car()

# ------------------------
# Mixins in Python
"""
A Mixin is a design pattern for reusable functionality:

class SomeMixin:
    def something(self):
        pass

Use it when you want to add reusable behavior to multiple classes,
improving modularity. With Mixins, you control how features are added.

Guidelines for Mixins:
- Should not be extended further.
- Should not be instantiated directly.
- Mixins are implemented with multiple inheritance in Python.
"""

class Book:
    def __init__(self, name, content):
        self.name = name
        self.content = content

class BookHTMLMixin:
    def render(self):
        return f"<html><title>{self.name}</title><body>{self.content}</body></html>"

class BookHTML(Book, BookHTMLMixin):
    pass

book_html = BookHTML("The Chronicles of Narnia", "Percy Jackson and the Olympians: The Lightning Thief")
print(book_html.render())

# ------------------------
# Slicing data generated by an iterator

# Function that yields increasing numbers starting from n
def count(n):
    while True:
        yield n
        n += 1

# Start at 0
c = count(0)
print(c)  # This is a generator object

import itertools

# islice generates a slice of items from the iterator
print("Numbers 11 to 19 from count(0):")
for x in itertools.islice(c, 11, 20):
    print(x)

"""
The islice function from itertools is an iterator that yields only
the items in the desired slice.
"""
